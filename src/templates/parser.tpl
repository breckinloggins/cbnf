/**
 * @Grammar@ Parser automatically generated by cbnf.  Modification is not recommended
 */
#define DBG_ENABLED 	0
#define DBG(x)	if(DBG_ENABLED)	{fprintf(stderr, x);}

static token* this = 0;
static FILE* fd = 0;

/**
 * Allocates and initializes a new token on the heap
 */
static token* new_token()	{
	// TODO: We're taking up way too much time doing allocations here.  We should have a 
	// "token pool" so we can allocate a bunch of them at a time, and only make more when 
	// we're starting to run low
	token* t = (token*)malloc(sizeof(token));
	memset(t, 0, sizeof(token));
	
	return t;
}

/**
 * Helper function.  Makes a new token. 
 * fills it from the scanner, and sets it to the current token, ignoring the token 
 * types the parser doesn't currently care about
 */
static void next_token()	{
	//TODO: We are not keeping track of any of these tokens as we malloc them, we should 
	//		do so so we can free the memory they consumed
	
	token* t;
	while (1)	{
		t = new_token();
		get_token(fd, t);	
		if (t->type != COMMENT && t->type != COMMENT_BLOCK)	{
			// We've found a token we care about
			break;
		}
		
		// We don't care about this one
		free(t);
	}
	this = t;
}

/**
 * Unconditionally accepts the current token and fetches a new one
 */
static token* accept_this()	{
	token* last = this;
	next_token();
	
	return last;
}

/**
 * Accepts the current token iff it is of the given type, returns token ptr if the token 
 * is accepted, zero otherwise
 */
static token* accept(token_type type)	{
	token* last;
	if (this != 0 && this->type == type)	{
		last = this;
		next_token();
		return last;
	}
	
	return 0;
}

/**
 * Accepts the token if it is of the given type, or throws a syntax error otherwise
 */
static token* expect(token_type type)	{
	token* ret;
	if (!(ret = accept(type)))	{
		ret = 0;
		fprintf(stderr, "Syntax error: Expected %s but got %s (%s)\n", 
			get_token_name(type), get_token_name(this->type), this->string);
		exit(1);
	}
	
	return ret;
}

/* Prototypes */
@#Rule_Prototype@void parse_@Name@();@BI_NEWLINE@@/Rule_Prototype@

@#Rule@
void parse_@Name@()   {
    /* Parse rule @Name@ here */
}
@#Rule_separator@@BI_NEWLINE@@/Rule_separator@
@/Rule@